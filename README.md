***Тестовое задание Bonusmoney***

--------------------------------

Задание 1

Получить карточку товара исходя из ее группы. 
Имеются следующие таблицы: 

Таблица с группами товаров (группа в группе - ее parentId = groupId родителя,
у корневой группы parentId = null):
group (
groupId VARCHAR(200) UNIQUE NOT NULL,
parentId VARCHAR(200),
name VARCHAR(200) NOT NULL
);

Таблица с карточками товаров для группы:
positionCard (
id VARCHAR(200) PRIMARY KEY,
isShowInApp BOOLEAN DEFAULT FALSE,
name VARCHAR(200),
groupId VARCHAR(200) NOT NULL
);

Реализовать функцию DAO для получения имени (positionCard.name) карточки 
товара по его группе, groupId - параметр функции. 
Если у группы не задана карточка товара, то тогда у 
этого товара карточка ее родителя, и т.д. 
Если карточка не задана ни у кого, то вернуть null.
Реализовать за 1 sql запрос. 

--------------------------------

Задание 2 

Реализовать получение/обновление токена для доступа к сторонней системе, например для 
отправки сообщений. Токен требуется в одном экземпляре на сервере и имеет конечное время 
жизни, например пол часа. 

Вам дан класс для работы с токеном TokenProvider и сам Token:

class TokenProvider {

   // возвращает токен
   public Token getToken() throws SomeExсeptions {
      // ..
   }

}

class Token {

   // возвращает время окончания токена
   public Date getExpirationTime() {
      // ..
   }

   // обновляет токен
   public void refresh() throws SomeExсeptions {
      // ..
   }

}

Требуется реализовать класс TokenUtil с одним методом getToken() 
возвращающим валидный Token или null в случае неуспешного получения.
Функция getToken должна отработать максимум за 15 секунд, при этом 
по возможности слать минимальное число запросов TokenProvider.getToken() и 
Token.refresh(). Учесть что функции TokenProvider.getToken() и Token.refresh() 
шлют запросы к сторонней системе и могут отрабатывать очень долго или 
вообще повиснуть. Поскольку это все на сервере, реализуемую функцию 
TokenUtil.getToken() могут вызвать много потоков одновременно.  

--------------------------------

Задание 3 

Реализовать запрос для загрузки клиентов из БД. 

Имеется база клиентов c их данными, следующего типа: 

табличка customer является центральной 

customer (
customerId VARCHAR(200) NOT NULL UNIQUE, 
col_1 SOME TYPE,
...
col_N SOME TYPE
)

Несколько десятков O(1) (например 30) табличек с типом связи 1 к 1 о данных клиента:

table_i (
customerId VARCHAR(200) NOT NULL UNIQUE REFERENCES customer (customerId),
col_1 SOME TYPE,
...
col_N SOME TYPE
)

И одна табличка с типом связи 1 к M о группах в которых состоит клиент:

table_many (
customerId VARCHAR(200) NOT NULL REFERENCES customer (customerId),
groupId INT NOT NULL
)

известно, что групп в которых состоит клиент не очень много - O(1) 
(считайте максимум несколько десятков).

в этом задании предполагается что нет длинных колонок типа TEXT, массивов и т.д. 
с большим объемом данных в них.

Задача реализовать запрос подгрузки клиентов с их данными и группами 
(все данные таблиц о которых было сказанно ранее, в том числе все группы).
Необходимо сделать роутер /getCustomers принимающий параметр отступ (в теле json), 
для загрузки следующей порции (5000) клиентов. 

В задаче требуется учесть быстродействие, 
клиентов может быть 300 тыс. - 1000 тыс. 
Что выбрать в качестве отступа?
Реализовывать авторизацию не нужно. 
Требуется реализовать отдачу блока 5 тыс. клиентов с данными за 2-4 сек на 
вашем ПК. То есть ПК может быть условно с 1-м ядром, а не заряженный сервак. 


